from sage.matrix.constructor import matrix, identity_matrix
from sage.matrix.matrix_space import MatrixSpace
from sage.groups.group import Group
from sage.categories.groups import Groups
from sage.structure.element import MultiplicativeGroupElement
from sage.modules.free_module import VectorSpace

from sage.rings.integer import Integer

ZZ_0 = Integer(0)
ZZ_1 = Integer(1)
ZZ_2 = Integer(2)
ZZ_3 = Integer(3)
ZZ_4 = Integer(4)


class Similarity(MultiplicativeGroupElement):
    
    def __init__(self, parent, m, v):
        r'''Construct the similarity w mapsto m*w+v from a 2x2 matrix and a vector.'''
        if parent is None:
            raise ValueError("The parent must be provided")
        self._m=m
        self._v=v
        self._parent=parent
        MultiplicativeGroupElement.__init__(self,parent)

    def _mul_(self,s):
        r'''Compose two similairities.'''
        return Similarity(self._parent,self._m*s._m,self._m*s._v+self._v)

    def __invert__(self):
        r'''Compose two similairities.'''
        mi = ~self._m
        return Similarity(self._parent,mi,-mi*self._v)

    def _div_(self,s):
        return self._mul_(s.__invert__())

    def __hash__(self):
        return 73*hash(self._m)-19*hash(self._v)

    def apply(self,w):
        r'''Return m*w+v.'''
        return self._m*w+self._v

    def apply_inverse(self, w):
        r'''s.apply_inverse(w) is the same as (~s).apply(w).'''
        mi = ~self._m
        return mi*w-mi*self._v

    def _repr_(self):
        return "Similarity w mapsto\n"+repr(self._m)+"*w + "+repr(self._v)

    def _cmp_(self, other):
        x=cmp(self._m,other._m)
        if x!=0:
            return x
        return cmp(self._v,other._v)

    __cmp__=_cmp_


class SimilarityGroup(Group):
    r'''Group representing all similarities in the plane.
    This is the group generated by rotations, translations and dilations.
    '''

    Element = Similarity

    def _element_constructor_(self, *args, **kwds):
        if len(args)!=1:
            return self.element_class(self, *args, **kwds)
        x = args[0]
        return self.element_class(self, x, **kwds)

    def __init__(self, base_field):
        self._f=base_field
        # The matrix space of 2x2 matrices
        self._ms = MatrixSpace(self._f,2,2)
        # The vector space of vectors 
        self._vs = VectorSpace(self._f,2)
        Group.__init__(self, category=Groups().Infinite())

    def _repr_(self):
        return "SimilarityGroup over field "+str(self._f)

    def one(self):
        return self.element_class(self,self._ms.one(),self._vs.zero())

    def an_element(self):
        return self.element_class(self,
            self._ms([[ZZ_3,ZZ_4],[-ZZ_4,ZZ_3]]),
            self._vs([ZZ_2,-ZZ_1]) )

    def is_abelian(self):
        return False

    def gens(self):
        matrices=[self._ms.one(),
            self._ms([[ZZ_2,ZZ_0],[ZZ_0,ZZ_2]]),
            self._ms([[ZZ_3,ZZ_4],[-ZZ_4,ZZ_3]]) ]
        print(matrices)
        l=[]
        for m in matrices:
            for v in self._vs.gens():
                print(m)
                l.append(self.element_class(self,m,v))
        return l
