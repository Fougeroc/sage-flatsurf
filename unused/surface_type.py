r"""
Generally useful tools for working with surfaces of all types.
"""

from flatsurf.geometry.matrix_2x2 import is_cosine_sine_of_rational


class SurfaceType:
    r"""
    This class contains a list of integers representing the various surface types. These surface types
    are related to the derivatives of the affine linear maps identifying the edges of the polygons in 
    the decomposition.
    """
    
    SIMILARITY = 0
    r"""
    Polygons with edges glued by similarity (Euclidean isometry followed by scaling)
    """
    
    HALF_DILATION = 1
    r"""Polygons glued by non-zero diagonal matrices."""
    
    DILATION = 2
    r"""Polygons glued by positive diagonal matrices."""

    CONE = 3
    r"""Polygons glued by Euclidean isometries."""
    
    RATIONAL_CONE = 4
    r"""Polygons glued by translations and finite order rotations."""
    
    HALF_TRANSLATION = 5
    r"""Polygons glued by translations and 180 degree rotations."""
    
    TRANSLATION = 6
    r"""Polygons glued by translation."""
    
    _type_to_string = { \
        0 : "Similarity surface", \
        1 : "Half-dilation surface", \
        2 : "Dilation surface", \
        3 : "Cone surface", \
        4 : "Rational cone surface", \
        5 : "Half-translation surface", \
        6 : "Translation surface"}
        
def surface_type_to_str(surface_type):
    r"""
    Return a string representation of the provided integer reprenting a surface type.
    """
    return SurfaceType._type_to_string[surface_type]

def surface_type_from_matrix(m):
    r"""
    Return the most specific type of surface possible for a surface with the monodromy matrix provided.
    The matrix provided should be a 2x2 matrix which lies in the similarity group 
    (i.e., the group generated by rotations and dilations).
    """
    # Ensure that we lie in the similarity group. 
    assert m[0][0]==m[1][1] and m[1][0] == - m[0][1]
    # Assuming entries are real this guarantees non-negative determinant and
    # the only way the matrix could be degererate is if it is zero.
    if m[0][1]==0:
        # We are diagonal.
        if m[0][0]==0:
            raise ValueError("Provided zero matrix.")
        if m[0][0]>0:
            if m[0][0]==1:
                return SurfaceType.TRANSLATION
            return SurfaceType.DILATION
        # Here m[0][0]<0:
        if m[0][0] == -1:
            return SurfaceType.HALF_TRANSLATION
        return SurfaceType.HALF_DILATION
    if m.det()==1:
        if is_cosine_sine_of_rational(m[0][0],m[1][0]):
            return SurfaceType.RATIONAL_CONE
        return SurfaceType.CONE
    return SurfaceType.SIMILARITY

def combine_surface_types(st, type2):
    r"""
    Return the most specific type of surface possible in a surface where
    two monodromies have one of two provided types.
    """
    # Probably often in practice the types will agree:
    if st==type2:
        return st
        
    # Deal with the case when one is a translation
    if st==SurfaceType.TRANSLATION:
        return type2
    if type2==SurfaceType.TRANSLATION:
        return st
    # Now neither is a translation.
    
    # Deal with the case when one is a similarity:
    if st==SurfaceType.SIMILARITY or type2==SurfaceType.SIMILARITY:
        return SurfaceType.SIMILARITY
    
    # Deal with the case when one is a half-translation.
    if st==SurfaceType.HALF_TRANSLATION:
        if type2 == SurfaceType.DILATION:
            return SurfaceType.HALF_DILATION
        return type2
    if type2==SurfaceType.HALF_TRANSLATION:
        if st == SurfaceType.DILATION:
            return SurfaceType.HALF_DILATION
        return st
    # Now neither is a half-translation.
    
    # Deal with the case when one is a Dilation:
    if st==SurfaceType.DILATION:
        if type2==SurfaceType.CONE or type2==SurfaceType.RATIONAL_CONE:
            return SurfaceType.SIMILARITY
        return type2
    if type2==SurfaceType.DILATION:
        if st==SurfaceType.CONE or st==SurfaceType.RATIONAL_CONE:
            return SurfaceType.SIMILARITY
        return st
    
    # Now if one is Half-Dilation, then the combination must be Similarity
    # since we ruled out equality of types.
    if st==SurfaceType.HALF_DILATION or type2==SurfaceType.HALF_DILATION:
        return SurfaceType.SIMILARITY
    
    # At this point one must CONE and the other RATIONAL_CONE
    return SurfaceType.CONE
    
def is_half_dilation_surface_type(st):
    r"""Return if all the 2x2 gluing matrices are diagonal matrices."""
    return \
        st == SurfaceType.HALF_DILATION or \
        st == SurfaceType.DILATION or \
        st == SurfaceType.HALF_TRANSLATION or \
        st == SurfaceType.TRANSLATION

def is_dilation_surface_type(st):
    r"""Return if all the 2x2 gluing matrices are positive diagonal matrices."""
    return \
        st == SurfaceType.DILATION or \
        st == SurfaceType.TRANSLATION

def is_cone_surface_type(st):
    r"""Return if all the 2x2 gluing matrices lie in O(2)."""
    return \
        st == SurfaceType.CONE or \
        st == SurfaceType.RATIONAL_CONE or \
        st == SurfaceType.HALF_TRANSLATION or \
        st == SurfaceType.TRANSLATION

def is_rational_cone_surface_type(st):
    r"""Return if all the 2x2 gluing matrices are finite order elements of O(2)."""
    return \
        st == SurfaceType.RATIONAL_CONE or \
        st == SurfaceType.HALF_TRANSLATION or \
        st == SurfaceType.TRANSLATION

def is_half_translation_surface_type(st):
    r"""Return if all the 2x2 gluing matrices are in {I, -I}."""
    return \
        st == SurfaceType.HALF_TRANSLATION or \
        st == SurfaceType.TRANSLATION

def is_translation_surface_type(st):
    r"""Return if all the 2x2 gluing matrices are in {I, -I}."""
    return \
        st == SurfaceType.TRANSLATION

######
###### Returning best surface types


def surface_from_polygons_and_gluings(polygons, gluings):
    r"""
    Construct the most specific surface possible from the provided polygons and gluings.
    
    EXAMPLES::
        sage: from flatsurf.geometry.polygon import Polygons
        sage: K.<sqrt2> = NumberField(x**2 - 2, embedding=1.414)
        sage: octagon = Polygons(K)([(1,0),(sqrt2/2, sqrt2/2),(0, 1),(-sqrt2/2, sqrt2/2),(-1,0),(-sqrt2/2, -sqrt2/2),(0, -1),(sqrt2/2, -sqrt2/2)])
        sage: square1 = Polygons(K)([(1,0),(0,1),(-1,0),(0,-1)])
        sage: square2 = Polygons(K)([(sqrt2/2, sqrt2/2),(-sqrt2/2, sqrt2/2),(-sqrt2/2, -sqrt2/2),(sqrt2/2, -sqrt2/2)])
        sage: gluings=[((1,i),(0, (2*i+4)%8 )) for i in range(4)]
        sage: for i in range(4):
        ...       gluings.append( ((2,i), (0, (2*i+5)%8 )) )
        sage: from flatsurf.geometry.surface import surface_from_polygons_and_gluings
        sage: s=surface_from_polygons_and_gluings([octagon,square1,square2], gluings)
        sage: type(s)
        <class 'flatsurf.geometry.translation_surface.TranslationSurface_polygons_and_gluings'>
    """
    from flatsurf.geometry.similarity_surface import SimilaritySurface_polygons_and_gluings
    surface = SimilaritySurface_polygons_and_gluings(polygons,gluings)
    surface_type = surface.compute_surface_type_from_gluings()
    if is_translation_surface_type(surface_type):
        from flatsurf.geometry.translation_surface import TranslationSurface_polygons_and_gluings
        surface = TranslationSurface_polygons_and_gluings(polygons,gluings)
    elif is_rational_cone_surface_type(surface_type):
        from flatsurf.geometry.rational_cone_surface import RationalConeSurface_polygons_and_gluings
        surface = RationalConeSurface_polygons_and_gluings(polygons,gluings)
    elif is_cone_surface_type(surface_type):
        from flatsurf.geometry.cone_surface import ConeSurface_polygons_and_gluings
        surface = ConeSurface_polygons_and_gluings(polygons,gluings)
    #surface._check()
    return surface
    
def convert_to_type(surface, surface_type):
    r"""
    Converts the provided surface to one of the given type.
    """
    if surface_type == SurfaceType.SIMILARITY:
        from flatsurf.geometry.similarity_surface import convert_to_similarity_surface
        return convert_to_similarity_surface(surface)
    if surface_type == SurfaceType.HALF_DILATION:
        from flatsurf.geometry.half_dilation_surface import convert_to_half_dilation_surface
        return convert_to_half_dilation_surface(surface)
    if surface_type == SurfaceType.CONE:
        from flatsurf.geometry.cone_surface import convert_to_cone_surface
        return convert_to_cone_surface(surface)
    if surface_type == SurfaceType.RATIONAL_CONE:
        from flatsurf.geometry.rational_cone_surface import convert_to_rational_cone_surface
        return convert_to_rational_cone_surface(surface)
    if surface_type == SurfaceType.TRANSLATION:
        from flatsurf.geometry.translation_surface import convert_to_translation_surface
        return convert_to_translation_surface(surface)
    raise NotImplementedError("Not implemented for surfaces of type %s."%surface_type_to_str(surface_type))

