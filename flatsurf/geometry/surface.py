r"""
Generally useful tools for working with surfaces of all types.
"""

from flatsurf.geometry.matrix_2x2 import is_cosine_sine_of_rational


class SurfaceType:
    r"""
    This class contains a list of integers representing the various surface types. These surface types
    are related to the derivatives of the affine linear maps identifying the edges of the polygons in 
    the decomposition.
    """
    
    SIMILARITY = 0
    r"""
    Polygons with edges glued by similarity (Euclidean isometry followed by scaling)
    """
    
    HALF_DILATION = 1
    r"""Polygons glued by non-zero diagonal matrices."""
    
    DILATION = 2
    r"""Polygons glued by positive diagonal matrices."""

    CONE = 3
    r"""Polygons glued by Euclidean isometries."""
    
    RATIONAL_CONE = 4
    r"""Polygons glued by translations and finite order rotations."""
    
    HALF_TRANSLATION = 5
    r"""Polygons glued by translations and 180 degree rotations."""
    
    TRANSLATION = 6
    r"""Polygons glued by translation."""
    
    _type_to_string = { \
        0 : "Similarity surface", \
        1 : "Half-dilation surface", \
        2 : "Dilation surface", \
        3 : "Cone surface", \
        4 : "Rational cone surface", \
        5 : "Half-translation surface", \
        6 : "Translation surface"}
        
def surface_type_to_str(surface_type):
    r"""
    Return a string representation of the provided integer reprenting a surface type.
    """
    return SurfaceType._type_to_string[surface_type]

def surface_type_from_matrix(m):
    r"""
    Return the most specific type of surface possible for a surface with the monodromy matrix provided.
    The matrix provided should be a 2x2 matrix which lies in the similarity group 
    (i.e., the group generated by rotations and dilations).
    """
    # Ensure that we lie in the similarity group. 
    assert m[0][0]==m[1][1] and m[1][0] == - m[0][1]
    # Assuming entries are real this guarantees non-negative determinant and
    # the only way the matrix could be degererate is if it is zero.
    if m[0][1]==0:
        # We are diagonal.
        if m[0][0]==0:
            raise ValueError("Provided zero matrix.")
        if m[0][0]>0:
            if m[0][0]==1:
                return SurfaceType.TRANSLATION
            return SurfaceType.DILATION
        # Here m[0][0]<0:
        if m[0][0] == -1:
            return SurfaceType.HALF_TRANSLATION
        return SurfaceType.HALF_DILATION
    if m.det()==1:
        if is_cosine_sine_of_rational(m[0][0],m[1][0]):
            return SurfaceType.RATIONAL_CONE
        return SurfaceType.CONE
    return SurfaceType.SIMILARITY

def combine_surface_types(st, type2):
    r"""
    Return the most specific type of surface possible in a surface where
    two monodromies have one of two provided types.
    """
    # Probably often in practice the types will agree:
    if st==type2:
        return st
        
    # Deal with the case when one is a translation
    if st==SurfaceType.TRANSLATION:
        return type2
    if type2==SurfaceType.TRANSLATION:
        return st
    # Now neither is a translation.
    
    # Deal with the case when one is a similarity:
    if st==SurfaceType.SIMILARITY or type2==SurfaceType.SIMILARITY:
        return SurfaceType.SIMILARITY
    
    # Deal with the case when one is a half-translation.
    if st==SurfaceType.HALF_TRANSLATION:
        if type2 == SurfaceType.DILATION:
            return SurfaceType.HALF_DILATION
        return type2
    if type2==SurfaceType.HALF_TRANSLATION:
        if st == SurfaceType.DILATION:
            return SurfaceType.HALF_DILATION
        return st
    # Now neither is a half-translation.
    
    # Deal with the case when one is a Dilation:
    if st==SurfaceType.DILATION:
        if type2==SurfaceType.CONE or type2==SurfaceType.RATIONAL_CONE:
            return SurfaceType.SIMILARITY
        return type2
    if type2==SurfaceType.DILATION:
        if st==SurfaceType.CONE or st==SurfaceType.RATIONAL_CONE:
            return SurfaceType.SIMILARITY
        return st
    
    # Now if one is Half-Dilation, then the combination must be Similarity
    # since we ruled out equality of types.
    if st==SurfaceType.HALF_DILATION or type2==SurfaceType.HALF_DILATION:
        return SurfaceType.SIMILARITY
    
    # At this point one must CONE and the other RATIONAL_CONE
    return SurfaceType.CONE
    
def is_half_dilation_surface_type(st):
    r"""Return if all the 2x2 gluing matrices are diagonal matrices."""
    return \
        st == SurfaceType.HALF_DILATION or \
        st == SurfaceType.DILATION or \
        st == SurfaceType.HALF_TRANSLATION or \
        st == SurfaceType.TRANSLATION

def is_dilation_surface_type(st):
    r"""Return if all the 2x2 gluing matrices are positive diagonal matrices."""
    return \
        st == SurfaceType.DILATION or \
        st == SurfaceType.TRANSLATION

def is_cone_surface_type(st):
    r"""Return if all the 2x2 gluing matrices lie in O(2)."""
    return \
        st == SurfaceType.CONE or \
        st == SurfaceType.RATIONAL_CONE or \
        st == SurfaceType.HALF_TRANSLATION or \
        st == SurfaceType.TRANSLATION

def is_rational_cone_surface_type(st):
    r"""Return if all the 2x2 gluing matrices are finite order elements of O(2)."""
    return \
        st == SurfaceType.RATIONAL_CONE or \
        st == SurfaceType.HALF_TRANSLATION or \
        st == SurfaceType.TRANSLATION

def is_half_translation_surface_type(st):
    r"""Return if all the 2x2 gluing matrices are in {I, -I}."""
    return \
        st == SurfaceType.HALF_TRANSLATION or \
        st == SurfaceType.TRANSLATION

def is_translation_surface_type(st):
    r"""Return if all the 2x2 gluing matrices are in {I, -I}."""
    return \
        st == SurfaceType.TRANSLATION

######
###### Returning best surface types


def surface_from_polygons_and_gluings(polygons, gluings):
    r"""
    Construct the most specific surface possible from the provided polygons and gluings.
    
    EXAMPLES::
        sage: from flatsurf.geometry.polygon import Polygons
        sage: K.<sqrt2> = NumberField(x**2 - 2, embedding=1.414)
        sage: octagon = Polygons(K)([(1,0),(sqrt2/2, sqrt2/2),(0, 1),(-sqrt2/2, sqrt2/2),(-1,0),(-sqrt2/2, -sqrt2/2),(0, -1),(sqrt2/2, -sqrt2/2)])
        sage: square1 = Polygons(K)([(1,0),(0,1),(-1,0),(0,-1)])
        sage: square2 = Polygons(K)([(sqrt2/2, sqrt2/2),(-sqrt2/2, sqrt2/2),(-sqrt2/2, -sqrt2/2),(sqrt2/2, -sqrt2/2)])
        sage: gluings=[((1,i),(0, (2*i+4)%8 )) for i in range(4)]
        sage: for i in range(4):
        ...       gluings.append( ((2,i), (0, (2*i+5)%8 )) )
        sage: from flatsurf.geometry.surface import surface_from_polygons_and_gluings
        sage: s=surface_from_polygons_and_gluings([octagon,square1,square2], gluings)
        sage: type(s)
        <class 'flatsurf.geometry.translation_surface.TranslationSurface_polygons_and_gluings'>
    """
    from flatsurf.geometry.similarity_surface import SimilaritySurface_polygons_and_gluings
    surface = SimilaritySurface_polygons_and_gluings(polygons,gluings)
    surface_type = surface.compute_surface_type_from_gluings()
    if is_translation_surface_type(surface_type):
        from flatsurf.geometry.translation_surface import TranslationSurface_polygons_and_gluings
        surface = TranslationSurface_polygons_and_gluings(polygons,gluings)
    elif is_rational_cone_surface_type(surface_type):
        from flatsurf.geometry.rational_cone_surface import RationalConeSurface_polygons_and_gluings
        surface = RationalConeSurface_polygons_and_gluings(polygons,gluings)
    elif is_cone_surface_type(surface_type):
        from flatsurf.geometry.cone_surface import ConeSurface_polygons_and_gluings
        surface = ConeSurface_polygons_and_gluings(polygons,gluings)
    #surface._check()
    return surface
    
def convert_to_type(surface, surface_type):
    r"""
    Converts the provided surface to one of the given type.
    """
    if surface_type == SurfaceType.SIMILARITY:
        from flatsurf.geometry.similarity_surface import convert_to_similarity_surface
        return convert_to_similarity_surface(surface)
    if surface_type == SurfaceType.HALF_DILATION:
        from flatsurf.geometry.half_dilation_surface import convert_to_half_dilation_surface
        return convert_to_half_dilation_surface(surface)
    if surface_type == SurfaceType.CONE:
        from flatsurf.geometry.cone_surface import convert_to_cone_surface
        return convert_to_cone_surface(surface)
    if surface_type == SurfaceType.RATIONAL_CONE:
        from flatsurf.geometry.rational_cone_surface import convert_to_rational_cone_surface
        return convert_to_rational_cone_surface(surface)
    if surface_type == SurfaceType.TRANSLATION:
        from flatsurf.geometry.translation_surface import convert_to_translation_surface
        return convert_to_translation_surface(surface)
    raise NotImplementedError("Not implemented for surfaces of type %s."%surface_type_to_str(surface_type))

#####
##### LABEL WALKER
#####

from collections import deque

class LabelWalker:
    r"""
    Take a canonical walk around the surface and find the labels of polygons.

    We start at the base_label().
    Then the labels are visited in order involving the combinatorial distance from the base_label(),
    where combinatorial distance measures the minimal number of edges which need to be crossed to reach the
    polygon with a givel label. Ties are broken using lexigraphical order on the numbers associated to edges crossed
    (labels are not used in this lexigraphical ordering).
    """
    
    class LabelWalkerIterator:
        def __init__(self, label_walker):
            self._lw = label_walker
            self._i = 0
        
        def next(self):
            if self._i < len(self._lw):
                label = self._lw.number_to_label(self._i)
                self._i = self._i +1
                return label
            if self._i == len(self._lw):
                label = self._lw.find_a_new_label()
                if label is None:
                    raise StopIteration()
                self._i = self._i+1
                return label
            raise StopIteration()
            
        def __iter__(self):
            return self
    
    def __init__(self, surface):
        self._s=surface
        self._labels=[self._s.base_label()]
        self._label_dict={self._s.base_label():0}
        
        # This will stores an edge to move through to get to a polygon closer to the base_polygon
        self._label_edge_back = {self._s.base_label():None} 
        
        self._walk=deque()
        self._walk.append((self._s.base_label(),0))
    
    def label_dictionary(self):
        r""" 
        Return a dictionary mapping labels to integers which gives a canonical order on labels.
        """
        return self._label_dict
    
    def edge_back(self, label, limit=None):
        r"""
        Return the `canonical' edge to walk through to get closer to the base_label, 
        or None if label already is the base_label.
        
        Remark: This could be slow on infinite surfaces!
        """
        try:
            return self._label_edge_back[label]
        except KeyError:
            if limit is None:
                if not self._s.is_finite():
                    limit=1000
                else:
                    limit=self._s.num_polygons()
            for i in xrange(limit):
                new_label=self.find_a_new_label()
                if label == new_label:
                    return self._label_edge_back[label]
        # Maybe the surface is not connected?
        raise KeyError("Unable to find label %s. Are you sure the surface is connected?"%(label))
    
    def __iter__(self):
        return LabelWalker.LabelWalkerIterator(self)

    def polygon_iterator(self):
        for label in self:
            yield self._s.polygon(label)

    def label_polygon_iterator(self):
        for label in self:
            yield label, self._s.polygon(label)

    def edge_iterator(self):
        for label,polygon in self.label_polygon_iterator():
            for e in xrange(polygon.num_edges()):
                yield label,e

    def __len__(self):
        r"""
        Return the number of labels found.
        """
        return len(self._labels)

    def find_a_new_label(self):
        r"""
        Finds a new label, stores it, and returns it. Returns None if we have already found all labels.
        """
        while len(self._walk)>0:
            label,e = self._walk.popleft()
            opposite_label,opposite_edge=self._s.opposite_edge(label,e)
            e=e+1
            if e < self._s.polygon(label).num_edges():
                self._walk.appendleft((label,e))
            if not opposite_label in self._label_dict:
                n=len(self._labels)
                self._labels.append(opposite_label)
                self._label_dict[opposite_label]=n
                self._walk.append((opposite_label,0))
                self._label_edge_back[opposite_label]=opposite_edge
                return opposite_label
        return None

    def find_new_labels(self,n):
        r"""
        Look for n new labels. Return the list of labels found.
        """
        new_labels = []
        for i in range(n):
            label = self.find_a_new_label()
            if label is None:
                return new_labels
            else:
                new_labels.append(label)
        return new_labels
        
        
    def find_all_labels(self):
        assert(self._s.is_finite())
        label = self.find_a_new_label()
        while not label is None:
            label = self.find_a_new_label()
            
    def number_to_label(self, n):
        r"""
        Return the n-th label where n is less than the length.
        """
        return self._labels[n]
    
    def label_to_number(self, label):
        r"""
        Return the number associated to the provided label (which must have already been found).
        """
        return self._label_dict[label]

    def surface(self):
        return self._s
